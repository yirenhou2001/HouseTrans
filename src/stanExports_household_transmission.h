// Generated by rstantools.  Do not edit by hand.

#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_household_transmission_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 256> locations_array__ =
  {" (found before start of program)",
  " (in 'household_transmission', line 70, column 2 to column 34)",
  " (in 'household_transmission', line 71, column 2 to column 36)",
  " (in 'household_transmission', line 72, column 2 to column 17)",
  " (in 'household_transmission', line 73, column 2 to column 17)",
  " (in 'household_transmission', line 74, column 2 to column 22)",
  " (in 'household_transmission', line 75, column 2 to column 40)",
  " (in 'household_transmission', line 76, column 2 to column 38)",
  " (in 'household_transmission', line 77, column 2 to column 21)",
  " (in 'household_transmission', line 78, column 2 to column 25)",
  " (in 'household_transmission', line 79, column 2 to column 27)",
  " (in 'household_transmission', line 80, column 2 to column 25)",
  " (in 'household_transmission', line 83, column 2 to column 33)",
  " (in 'household_transmission', line 84, column 2 to column 35)",
  " (in 'household_transmission', line 85, column 2 to column 24)",
  " (in 'household_transmission', line 86, column 2 to column 49)",
  " (in 'household_transmission', line 87, column 2 to column 30)",
  " (in 'household_transmission', line 88, column 2 to column 30)",
  " (in 'household_transmission', line 107, column 2 to column 51)",
  " (in 'household_transmission', line 90, column 2 to column 33)",
  " (in 'household_transmission', line 92, column 4 to column 67)",
  " (in 'household_transmission', line 91, column 17 to line 93, column 3)",
  " (in 'household_transmission', line 91, column 2 to line 93, column 3)",
  " (in 'household_transmission', line 94, column 2 to column 37)",
  " (in 'household_transmission', line 96, column 4 to column 73)",
  " (in 'household_transmission', line 95, column 17 to line 97, column 3)",
  " (in 'household_transmission', line 95, column 2 to line 97, column 3)",
  " (in 'household_transmission', line 100, column 11 to column 12)",
  " (in 'household_transmission', line 100, column 4 to column 24)",
  " (in 'household_transmission', line 102, column 6 to column 62)",
  " (in 'household_transmission', line 101, column 19 to line 103, column 5)",
  " (in 'household_transmission', line 101, column 4 to line 103, column 5)",
  " (in 'household_transmission', line 104, column 4 to column 45)",
  " (in 'household_transmission', line 99, column 2 to line 105, column 3)",
  " (in 'household_transmission', line 112, column 10 to column 29)",
  " (in 'household_transmission', line 118, column 12 to column 67)",
  " (in 'household_transmission', line 116, column 17 to line 119, column 11)",
  " (in 'household_transmission', line 115, column 12 to column 69)",
  " (in 'household_transmission', line 113, column 28 to line 116, column 11)",
  " (in 'household_transmission', line 113, column 10 to line 119, column 11)",
  " (in 'household_transmission', line 111, column 26 to line 120, column 9)",
  " (in 'household_transmission', line 111, column 8 to line 120, column 9)",
  " (in 'household_transmission', line 110, column 21 to line 121, column 7)",
  " (in 'household_transmission', line 110, column 6 to line 121, column 7)",
  " (in 'household_transmission', line 109, column 19 to line 122, column 5)",
  " (in 'household_transmission', line 109, column 4 to line 122, column 5)",
  " (in 'household_transmission', line 108, column 24 to line 123, column 3)",
  " (in 'household_transmission', line 108, column 2 to line 123, column 3)",
  " (in 'household_transmission', line 127, column 2 to column 37)",
  " (in 'household_transmission', line 128, column 2 to column 39)",
  " (in 'household_transmission', line 133, column 4 to column 70)",
  " (in 'household_transmission', line 132, column 36 to line 134, column 3)",
  " (in 'household_transmission', line 132, column 9 to line 134, column 3)",
  " (in 'household_transmission', line 131, column 4 to column 69)",
  " (in 'household_transmission', line 130, column 29 to line 132, column 3)",
  " (in 'household_transmission', line 130, column 2 to line 134, column 3)",
  " (in 'household_transmission', line 138, column 4 to column 70)",
  " (in 'household_transmission', line 137, column 36 to line 139, column 3)",
  " (in 'household_transmission', line 137, column 9 to line 139, column 3)",
  " (in 'household_transmission', line 136, column 4 to column 69)",
  " (in 'household_transmission', line 135, column 29 to line 137, column 3)",
  " (in 'household_transmission', line 135, column 2 to line 139, column 3)",
  " (in 'household_transmission', line 143, column 4 to column 75)",
  " (in 'household_transmission', line 142, column 36 to line 144, column 3)",
  " (in 'household_transmission', line 142, column 9 to line 144, column 3)",
  " (in 'household_transmission', line 141, column 4 to column 74)",
  " (in 'household_transmission', line 140, column 29 to line 142, column 3)",
  " (in 'household_transmission', line 140, column 2 to line 144, column 3)",
  " (in 'household_transmission', line 150, column 6 to column 68)",
  " (in 'household_transmission', line 149, column 36 to line 151, column 5)",
  " (in 'household_transmission', line 149, column 11 to line 151, column 5)",
  " (in 'household_transmission', line 148, column 6 to column 67)",
  " (in 'household_transmission', line 147, column 29 to line 149, column 5)",
  " (in 'household_transmission', line 147, column 4 to line 151, column 5)",
  " (in 'household_transmission', line 146, column 18 to line 152, column 3)",
  " (in 'household_transmission', line 146, column 2 to line 152, column 3)",
  " (in 'household_transmission', line 157, column 6 to column 67)",
  " (in 'household_transmission', line 156, column 36 to line 158, column 5)",
  " (in 'household_transmission', line 156, column 11 to line 158, column 5)",
  " (in 'household_transmission', line 155, column 6 to column 66)",
  " (in 'household_transmission', line 154, column 29 to line 156, column 5)",
  " (in 'household_transmission', line 154, column 4 to line 158, column 5)",
  " (in 'household_transmission', line 153, column 17 to line 159, column 3)",
  " (in 'household_transmission', line 153, column 2 to line 159, column 3)",
  " (in 'household_transmission', line 166, column 4 to column 72)",
  " (in 'household_transmission', line 165, column 36 to line 167, column 3)",
  " (in 'household_transmission', line 165, column 9 to line 167, column 3)",
  " (in 'household_transmission', line 164, column 4 to column 70)",
  " (in 'household_transmission', line 163, column 36 to line 165, column 3)",
  " (in 'household_transmission', line 163, column 9 to line 167, column 3)",
  " (in 'household_transmission', line 162, column 4 to column 69)",
  " (in 'household_transmission', line 161, column 29 to line 163, column 3)",
  " (in 'household_transmission', line 161, column 2 to line 167, column 3)",
  " (in 'household_transmission', line 173, column 4 to column 69)",
  " (in 'household_transmission', line 172, column 35 to line 174, column 3)",
  " (in 'household_transmission', line 172, column 9 to line 174, column 3)",
  " (in 'household_transmission', line 171, column 4 to column 67)",
  " (in 'household_transmission', line 170, column 35 to line 172, column 3)",
  " (in 'household_transmission', line 170, column 9 to line 174, column 3)",
  " (in 'household_transmission', line 169, column 4 to column 66)",
  " (in 'household_transmission', line 168, column 28 to line 170, column 3)",
  " (in 'household_transmission', line 168, column 2 to line 174, column 3)",
  " (in 'household_transmission', line 180, column 4 to column 65)",
  " (in 'household_transmission', line 179, column 35 to line 181, column 3)",
  " (in 'household_transmission', line 179, column 9 to line 181, column 3)",
  " (in 'household_transmission', line 178, column 4 to column 63)",
  " (in 'household_transmission', line 177, column 35 to line 179, column 3)",
  " (in 'household_transmission', line 177, column 9 to line 181, column 3)",
  " (in 'household_transmission', line 176, column 4 to column 62)",
  " (in 'household_transmission', line 175, column 28 to line 177, column 3)",
  " (in 'household_transmission', line 175, column 2 to line 181, column 3)",
  " (in 'household_transmission', line 187, column 4 to column 71)",
  " (in 'household_transmission', line 186, column 36 to line 188, column 3)",
  " (in 'household_transmission', line 186, column 9 to line 188, column 3)",
  " (in 'household_transmission', line 185, column 4 to column 69)",
  " (in 'household_transmission', line 184, column 36 to line 186, column 3)",
  " (in 'household_transmission', line 184, column 9 to line 188, column 3)",
  " (in 'household_transmission', line 183, column 4 to column 68)",
  " (in 'household_transmission', line 182, column 29 to line 184, column 3)",
  " (in 'household_transmission', line 182, column 2 to line 188, column 3)",
  " (in 'household_transmission', line 191, column 4 to column 64)",
  " (in 'household_transmission', line 193, column 4 to column 28)",
  " (in 'household_transmission', line 195, column 6 to column 55)",
  " (in 'household_transmission', line 194, column 20 to line 196, column 5)",
  " (in 'household_transmission', line 194, column 4 to line 196, column 5)",
  " (in 'household_transmission', line 197, column 4 to column 63)",
  " (in 'household_transmission', line 199, column 6 to column 24)",
  " (in 'household_transmission', line 201, column 6 to column 75)",
  " (in 'household_transmission', line 203, column 6 to column 23)",
  " (in 'household_transmission', line 204, column 6 to column 67)",
  " (in 'household_transmission', line 206, column 8 to column 37)",
  " (in 'household_transmission', line 207, column 20 to column 26)",
  " (in 'household_transmission', line 207, column 8 to column 26)",
  " (in 'household_transmission', line 208, column 32 to column 41)",
  " (in 'household_transmission', line 208, column 8 to column 41)",
  " (in 'household_transmission', line 209, column 20 to column 29)",
  " (in 'household_transmission', line 209, column 8 to column 29)",
  " (in 'household_transmission', line 210, column 26 to column 35)",
  " (in 'household_transmission', line 210, column 8 to column 35)",
  " (in 'household_transmission', line 212, column 8 to column 31)",
  " (in 'household_transmission', line 214, column 10 to column 56)",
  " (in 'household_transmission', line 213, column 23 to line 215, column 9)",
  " (in 'household_transmission', line 213, column 8 to line 215, column 9)",
  " (in 'household_transmission', line 216, column 8 to column 70)",
  " (in 'household_transmission', line 218, column 8 to column 23)",
  " (in 'household_transmission', line 219, column 8 to column 47)",
  " (in 'household_transmission', line 221, column 10 to column 43)",
  " (in 'household_transmission', line 225, column 12 to column 22)",
  " (in 'household_transmission', line 224, column 17 to line 226, column 11)",
  " (in 'household_transmission', line 223, column 25 to column 47)",
  " (in 'household_transmission', line 223, column 12 to column 47)",
  " (in 'household_transmission', line 222, column 36 to line 224, column 11)",
  " (in 'household_transmission', line 222, column 10 to line 226, column 11)",
  " (in 'household_transmission', line 220, column 58 to line 227, column 9)",
  " (in 'household_transmission', line 220, column 8 to line 227, column 9)",
  " (in 'household_transmission', line 229, column 8 to column 26)",
  " (in 'household_transmission', line 231, column 10 to column 37)",
  " (in 'household_transmission', line 230, column 30 to line 232, column 9)",
  " (in 'household_transmission', line 230, column 8 to line 232, column 9)",
  " (in 'household_transmission', line 234, column 8 to column 27)",
  " (in 'household_transmission', line 238, column 10 to column 51)",
  " (in 'household_transmission', line 237, column 15 to line 239, column 9)",
  " (in 'household_transmission', line 236, column 10 to column 48)",
  " (in 'household_transmission', line 235, column 30 to line 237, column 9)",
  " (in 'household_transmission', line 235, column 8 to line 239, column 9)",
  " (in 'household_transmission', line 240, column 8 to column 58)",
  " (in 'household_transmission', line 241, column 8 to column 33)",
  " (in 'household_transmission', line 205, column 35 to line 242, column 7)",
  " (in 'household_transmission', line 205, column 6 to line 242, column 7)",
  " (in 'household_transmission', line 244, column 6 to column 46)",
  " (in 'household_transmission', line 246, column 6 to column 52)",
  " (in 'household_transmission', line 247, column 6 to column 59)",
  " (in 'household_transmission', line 198, column 36 to line 248, column 5)",
  " (in 'household_transmission', line 198, column 4 to line 248, column 5)",
  " (in 'household_transmission', line 190, column 17 to line 249, column 3)",
  " (in 'household_transmission', line 190, column 2 to line 249, column 3)",
  " (in 'household_transmission', line 2, column 2 to column 17)",
  " (in 'household_transmission', line 3, column 0 to column 15)",
  " (in 'household_transmission', line 4, column 2 to column 17)",
  " (in 'household_transmission', line 5, column 2 to column 17)",
  " (in 'household_transmission', line 6, column 2 to column 13)",
  " (in 'household_transmission', line 8, column 2 to column 36)",
  " (in 'household_transmission', line 9, column 2 to column 32)",
  " (in 'household_transmission', line 10, column 2 to column 40)",
  " (in 'household_transmission', line 12, column 8 to column 9)",
  " (in 'household_transmission', line 12, column 2 to column 39)",
  " (in 'household_transmission', line 13, column 8 to column 9)",
  " (in 'household_transmission', line 13, column 2 to column 41)",
  " (in 'household_transmission', line 14, column 8 to column 9)",
  " (in 'household_transmission', line 14, column 11 to column 12)",
  " (in 'household_transmission', line 14, column 2 to column 38)",
  " (in 'household_transmission', line 15, column 8 to column 9)",
  " (in 'household_transmission', line 15, column 11 to column 12)",
  " (in 'household_transmission', line 15, column 2 to column 38)",
  " (in 'household_transmission', line 16, column 8 to column 9)",
  " (in 'household_transmission', line 16, column 11 to column 12)",
  " (in 'household_transmission', line 16, column 2 to column 21)",
  " (in 'household_transmission', line 17, column 8 to column 9)",
  " (in 'household_transmission', line 17, column 2 to column 44)",
  " (in 'household_transmission', line 18, column 8 to column 9)",
  " (in 'household_transmission', line 18, column 2 to column 29)",
  " (in 'household_transmission', line 20, column 8 to column 9)",
  " (in 'household_transmission', line 20, column 2 to column 39)",
  " (in 'household_transmission', line 21, column 2 to column 27)",
  " (in 'household_transmission', line 22, column 8 to column 9)",
  " (in 'household_transmission', line 22, column 11 to column 22)",
  " (in 'household_transmission', line 22, column 2 to column 57)",
  " (in 'household_transmission', line 24, column 9 to column 10)",
  " (in 'household_transmission', line 24, column 12 to column 13)",
  " (in 'household_transmission', line 24, column 2 to column 36)",
  " (in 'household_transmission', line 26, column 2 to column 30)",
  " (in 'household_transmission', line 27, column 2 to column 32)",
  " (in 'household_transmission', line 29, column 2 to column 22)",
  " (in 'household_transmission', line 30, column 9 to column 10)",
  " (in 'household_transmission', line 30, column 12 to column 18)",
  " (in 'household_transmission', line 30, column 2 to column 27)",
  " (in 'household_transmission', line 31, column 2 to column 21)",
  " (in 'household_transmission', line 32, column 9 to column 10)",
  " (in 'household_transmission', line 32, column 12 to column 17)",
  " (in 'household_transmission', line 32, column 2 to column 25)",
  " (in 'household_transmission', line 36, column 2 to column 32)",
  " (in 'household_transmission', line 37, column 2 to column 31)",
  " (in 'household_transmission', line 39, column 2 to column 32)",
  " (in 'household_transmission', line 40, column 2 to column 31)",
  " (in 'household_transmission', line 42, column 2 to column 32)",
  " (in 'household_transmission', line 43, column 2 to column 31)",
  " (in 'household_transmission', line 45, column 2 to column 30)",
  " (in 'household_transmission', line 46, column 2 to column 29)",
  " (in 'household_transmission', line 48, column 2 to column 32)",
  " (in 'household_transmission', line 49, column 2 to column 31)",
  " (in 'household_transmission', line 50, column 2 to column 31)",
  " (in 'household_transmission', line 51, column 2 to column 30)",
  " (in 'household_transmission', line 52, column 2 to column 31)",
  " (in 'household_transmission', line 53, column 2 to column 30)",
  " (in 'household_transmission', line 54, column 2 to column 32)",
  " (in 'household_transmission', line 55, column 2 to column 31)",
  " (in 'household_transmission', line 58, column 8 to column 9)",
  " (in 'household_transmission', line 58, column 2 to column 29)",
  " (in 'household_transmission', line 60, column 4 to column 25)",
  " (in 'household_transmission', line 63, column 8 to column 29)",
  " (in 'household_transmission', line 64, column 8 to column 14)",
  " (in 'household_transmission', line 62, column 24 to line 65, column 7)",
  " (in 'household_transmission', line 62, column 6 to line 65, column 7)",
  " (in 'household_transmission', line 61, column 31 to line 66, column 5)",
  " (in 'household_transmission', line 61, column 4 to line 66, column 5)",
  " (in 'household_transmission', line 59, column 17 to line 67, column 3)",
  " (in 'household_transmission', line 59, column 2 to line 67, column 3)",
  " (in 'household_transmission', line 70, column 9 to column 12)",
  " (in 'household_transmission', line 71, column 9 to column 12)",
  " (in 'household_transmission', line 79, column 9 to column 15)",
  " (in 'household_transmission', line 80, column 9 to column 14)",
  " (in 'household_transmission', line 83, column 18 to column 19)",
  " (in 'household_transmission', line 84, column 18 to column 19)",
  " (in 'household_transmission', line 85, column 9 to column 10)",
  " (in 'household_transmission', line 107, column 9 to column 10)",
  " (in 'household_transmission', line 107, column 12 to column 13)"};
#include <stan_meta_header.hpp>
class model_household_transmission final : public model_base_crtp<model_household_transmission> {
private:
  int N;
  int T;
  int H;
  int R;
  double delta;
  int use_vl_data;
  int vl_type;
  int use_curve_logic;
  std::vector<int> hh_id;
  std::vector<int> role_id;
  std::vector<std::vector<int>> I;
  std::vector<std::vector<int>> Y;
  std::vector<std::vector<double>> V;
  std::vector<int> start_risk;
  std::vector<int> p_id;
  std::vector<int> hh_size_people;
  int hh_max_size;
  std::vector<std::vector<int>> hh_members;
  Eigen::Matrix<double,-1,-1> seasonal_forcing_mat_data__;
  double reference_phi;
  double reference_kappa;
  int K_susc;
  Eigen::Matrix<double,-1,-1> X_susc_data__;
  int K_inf;
  Eigen::Matrix<double,-1,-1> X_inf_data__;
  int prior_beta1_type;
  Eigen::Matrix<double,-1,1> prior_beta1_params_data__;
  int prior_beta2_type;
  Eigen::Matrix<double,-1,1> prior_beta2_params_data__;
  int prior_alpha_type;
  Eigen::Matrix<double,-1,1> prior_alpha_params_data__;
  int prior_cov_type;
  Eigen::Matrix<double,-1,1> prior_cov_params_data__;
  int prior_shape_type;
  Eigen::Matrix<double,-1,1> prior_shape_params_data__;
  int prior_rate_type;
  Eigen::Matrix<double,-1,1> prior_rate_params_data__;
  int prior_ct50_type;
  Eigen::Matrix<double,-1,1> prior_ct50_params_data__;
  int prior_slope_type;
  Eigen::Matrix<double,-1,1> prior_slope_params_data__;
  std::vector<int> infection_day;
  int log_phi_by_role_raw_1dim__;
  int log_kappa_by_role_raw_1dim__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> seasonal_forcing_mat{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_susc{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_inf{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_beta1_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_beta2_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_alpha_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_cov_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_shape_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_rate_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_ct50_params{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_slope_params{nullptr, 0};
public:
  ~model_household_transmission() {}
  model_household_transmission(stan::io::var_context& context__, unsigned int
                               random_seed__ = 0, std::ostream*
                               pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_household_transmission_namespace::model_household_transmission";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 176;
      context__.validate_dims("data initialization", "N", "int",
        std::vector<size_t>{});
      N = std::numeric_limits<int>::min();
      current_statement__ = 176;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 176;
      stan::math::check_greater_or_equal(function__, "N", N, 1);
      current_statement__ = 177;
      context__.validate_dims("data initialization", "T", "int",
        std::vector<size_t>{});
      T = std::numeric_limits<int>::min();
      current_statement__ = 177;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 177;
      stan::math::check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 178;
      context__.validate_dims("data initialization", "H", "int",
        std::vector<size_t>{});
      H = std::numeric_limits<int>::min();
      current_statement__ = 178;
      H = context__.vals_i("H")[(1 - 1)];
      current_statement__ = 178;
      stan::math::check_greater_or_equal(function__, "H", H, 1);
      current_statement__ = 179;
      context__.validate_dims("data initialization", "R", "int",
        std::vector<size_t>{});
      R = std::numeric_limits<int>::min();
      current_statement__ = 179;
      R = context__.vals_i("R")[(1 - 1)];
      current_statement__ = 179;
      stan::math::check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 180;
      context__.validate_dims("data initialization", "delta", "double",
        std::vector<size_t>{});
      delta = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 180;
      delta = context__.vals_r("delta")[(1 - 1)];
      current_statement__ = 181;
      context__.validate_dims("data initialization", "use_vl_data", "int",
        std::vector<size_t>{});
      use_vl_data = std::numeric_limits<int>::min();
      current_statement__ = 181;
      use_vl_data = context__.vals_i("use_vl_data")[(1 - 1)];
      current_statement__ = 181;
      stan::math::check_greater_or_equal(function__, "use_vl_data",
        use_vl_data, 0);
      current_statement__ = 181;
      stan::math::check_less_or_equal(function__, "use_vl_data", use_vl_data,
        1);
      current_statement__ = 182;
      context__.validate_dims("data initialization", "vl_type", "int",
        std::vector<size_t>{});
      vl_type = std::numeric_limits<int>::min();
      current_statement__ = 182;
      vl_type = context__.vals_i("vl_type")[(1 - 1)];
      current_statement__ = 182;
      stan::math::check_greater_or_equal(function__, "vl_type", vl_type, 0);
      current_statement__ = 182;
      stan::math::check_less_or_equal(function__, "vl_type", vl_type, 1);
      current_statement__ = 183;
      context__.validate_dims("data initialization", "use_curve_logic",
        "int", std::vector<size_t>{});
      use_curve_logic = std::numeric_limits<int>::min();
      current_statement__ = 183;
      use_curve_logic = context__.vals_i("use_curve_logic")[(1 - 1)];
      current_statement__ = 183;
      stan::math::check_greater_or_equal(function__, "use_curve_logic",
        use_curve_logic, 0);
      current_statement__ = 183;
      stan::math::check_less_or_equal(function__, "use_curve_logic",
        use_curve_logic, 1);
      current_statement__ = 184;
      stan::math::validate_non_negative_index("hh_id", "N", N);
      current_statement__ = 185;
      context__.validate_dims("data initialization", "hh_id", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      hh_id = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 185;
      hh_id = context__.vals_i("hh_id");
      current_statement__ = 185;
      stan::math::check_greater_or_equal(function__, "hh_id", hh_id, 1);
      current_statement__ = 185;
      stan::math::check_less_or_equal(function__, "hh_id", hh_id, H);
      current_statement__ = 186;
      stan::math::validate_non_negative_index("role_id", "N", N);
      current_statement__ = 187;
      context__.validate_dims("data initialization", "role_id", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      role_id = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 187;
      role_id = context__.vals_i("role_id");
      current_statement__ = 187;
      stan::math::check_greater_or_equal(function__, "role_id", role_id, 1);
      current_statement__ = 187;
      stan::math::check_less_or_equal(function__, "role_id", role_id, R);
      current_statement__ = 188;
      stan::math::validate_non_negative_index("I", "N", N);
      current_statement__ = 189;
      stan::math::validate_non_negative_index("I", "T", T);
      current_statement__ = 190;
      context__.validate_dims("data initialization", "I", "int",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(T)});
      I = std::vector<std::vector<int>>(N,
            std::vector<int>(T, std::numeric_limits<int>::min()));
      {
        std::vector<int> I_flat__;
        current_statement__ = 190;
        I_flat__ = context__.vals_i("I");
        current_statement__ = 190;
        pos__ = 1;
        current_statement__ = 190;
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          current_statement__ = 190;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 190;
            stan::model::assign(I, I_flat__[(pos__ - 1)],
              "assigning variable I", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 190;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 190;
      stan::math::check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 190;
      stan::math::check_less_or_equal(function__, "I", I, 1);
      current_statement__ = 191;
      stan::math::validate_non_negative_index("Y", "N", N);
      current_statement__ = 192;
      stan::math::validate_non_negative_index("Y", "T", T);
      current_statement__ = 193;
      context__.validate_dims("data initialization", "Y", "int",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(T)});
      Y = std::vector<std::vector<int>>(N,
            std::vector<int>(T, std::numeric_limits<int>::min()));
      {
        std::vector<int> Y_flat__;
        current_statement__ = 193;
        Y_flat__ = context__.vals_i("Y");
        current_statement__ = 193;
        pos__ = 1;
        current_statement__ = 193;
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          current_statement__ = 193;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 193;
            stan::model::assign(Y, Y_flat__[(pos__ - 1)],
              "assigning variable Y", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 193;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 193;
      stan::math::check_greater_or_equal(function__, "Y", Y, 0);
      current_statement__ = 193;
      stan::math::check_less_or_equal(function__, "Y", Y, 1);
      current_statement__ = 194;
      stan::math::validate_non_negative_index("V", "N", N);
      current_statement__ = 195;
      stan::math::validate_non_negative_index("V", "T", T);
      current_statement__ = 196;
      context__.validate_dims("data initialization", "V", "double",
        std::vector<size_t>{static_cast<size_t>(N), static_cast<size_t>(T)});
      V = std::vector<std::vector<double>>(N,
            std::vector<double>(T, std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> V_flat__;
        current_statement__ = 196;
        V_flat__ = context__.vals_r("V");
        current_statement__ = 196;
        pos__ = 1;
        current_statement__ = 196;
        for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
          current_statement__ = 196;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 196;
            stan::model::assign(V, V_flat__[(pos__ - 1)],
              "assigning variable V", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 196;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 197;
      stan::math::validate_non_negative_index("start_risk", "N", N);
      current_statement__ = 198;
      context__.validate_dims("data initialization", "start_risk", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      start_risk = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 198;
      start_risk = context__.vals_i("start_risk");
      current_statement__ = 198;
      stan::math::check_greater_or_equal(function__, "start_risk",
        start_risk, 1);
      current_statement__ = 198;
      stan::math::check_less_or_equal(function__, "start_risk", start_risk, T);
      current_statement__ = 199;
      stan::math::validate_non_negative_index("p_id", "N", N);
      current_statement__ = 200;
      context__.validate_dims("data initialization", "p_id", "int",
        std::vector<size_t>{static_cast<size_t>(N)});
      p_id = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 200;
      p_id = context__.vals_i("p_id");
      current_statement__ = 200;
      stan::math::check_greater_or_equal(function__, "p_id", p_id, 1);
      current_statement__ = 201;
      stan::math::validate_non_negative_index("hh_size_people", "H", H);
      current_statement__ = 202;
      context__.validate_dims("data initialization", "hh_size_people", "int",
        std::vector<size_t>{static_cast<size_t>(H)});
      hh_size_people = std::vector<int>(H, std::numeric_limits<int>::min());
      current_statement__ = 202;
      hh_size_people = context__.vals_i("hh_size_people");
      current_statement__ = 202;
      stan::math::check_greater_or_equal(function__, "hh_size_people",
        hh_size_people, 1);
      current_statement__ = 203;
      context__.validate_dims("data initialization", "hh_max_size", "int",
        std::vector<size_t>{});
      hh_max_size = std::numeric_limits<int>::min();
      current_statement__ = 203;
      hh_max_size = context__.vals_i("hh_max_size")[(1 - 1)];
      current_statement__ = 203;
      stan::math::check_greater_or_equal(function__, "hh_max_size",
        hh_max_size, 1);
      current_statement__ = 204;
      stan::math::validate_non_negative_index("hh_members", "H", H);
      current_statement__ = 205;
      stan::math::validate_non_negative_index("hh_members", "hh_max_size",
        hh_max_size);
      current_statement__ = 206;
      context__.validate_dims("data initialization", "hh_members", "int",
        std::vector<size_t>{static_cast<size_t>(H),
          static_cast<size_t>(hh_max_size)});
      hh_members = std::vector<std::vector<int>>(H,
                     std::vector<int>(hh_max_size,
                       std::numeric_limits<int>::min()));
      {
        std::vector<int> hh_members_flat__;
        current_statement__ = 206;
        hh_members_flat__ = context__.vals_i("hh_members");
        current_statement__ = 206;
        pos__ = 1;
        current_statement__ = 206;
        for (int sym1__ = 1; sym1__ <= hh_max_size; ++sym1__) {
          current_statement__ = 206;
          for (int sym2__ = 1; sym2__ <= H; ++sym2__) {
            current_statement__ = 206;
            stan::model::assign(hh_members, hh_members_flat__[(pos__ - 1)],
              "assigning variable hh_members",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 206;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 206;
      stan::math::check_greater_or_equal(function__, "hh_members",
        hh_members, 0);
      current_statement__ = 206;
      stan::math::check_less_or_equal(function__, "hh_members", hh_members, N);
      current_statement__ = 207;
      stan::math::validate_non_negative_index("seasonal_forcing_mat", "T", T);
      current_statement__ = 208;
      stan::math::validate_non_negative_index("seasonal_forcing_mat", "R", R);
      current_statement__ = 209;
      context__.validate_dims("data initialization", "seasonal_forcing_mat",
        "double",
        std::vector<size_t>{static_cast<size_t>(T), static_cast<size_t>(R)});
      seasonal_forcing_mat_data__ = Eigen::Matrix<double,-1,-1>::Constant(T,
                                      R,
                                      std::numeric_limits<double>::quiet_NaN());
      new (&seasonal_forcing_mat)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(seasonal_forcing_mat_data__.data(),
        T, R);
      {
        std::vector<local_scalar_t__> seasonal_forcing_mat_flat__;
        current_statement__ = 209;
        seasonal_forcing_mat_flat__ = context__.vals_r("seasonal_forcing_mat");
        current_statement__ = 209;
        pos__ = 1;
        current_statement__ = 209;
        for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
          current_statement__ = 209;
          for (int sym2__ = 1; sym2__ <= T; ++sym2__) {
            current_statement__ = 209;
            stan::model::assign(seasonal_forcing_mat,
              seasonal_forcing_mat_flat__[(pos__ - 1)],
              "assigning variable seasonal_forcing_mat",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 209;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 210;
      context__.validate_dims("data initialization", "reference_phi",
        "double", std::vector<size_t>{});
      reference_phi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 210;
      reference_phi = context__.vals_r("reference_phi")[(1 - 1)];
      current_statement__ = 210;
      stan::math::check_greater_or_equal(function__, "reference_phi",
        reference_phi, 0);
      current_statement__ = 211;
      context__.validate_dims("data initialization", "reference_kappa",
        "double", std::vector<size_t>{});
      reference_kappa = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 211;
      reference_kappa = context__.vals_r("reference_kappa")[(1 - 1)];
      current_statement__ = 211;
      stan::math::check_greater_or_equal(function__, "reference_kappa",
        reference_kappa, 0);
      current_statement__ = 212;
      context__.validate_dims("data initialization", "K_susc", "int",
        std::vector<size_t>{});
      K_susc = std::numeric_limits<int>::min();
      current_statement__ = 212;
      K_susc = context__.vals_i("K_susc")[(1 - 1)];
      current_statement__ = 212;
      stan::math::check_greater_or_equal(function__, "K_susc", K_susc, 0);
      current_statement__ = 213;
      stan::math::validate_non_negative_index("X_susc", "N", N);
      current_statement__ = 214;
      stan::math::validate_non_negative_index("X_susc", "K_susc", K_susc);
      current_statement__ = 215;
      context__.validate_dims("data initialization", "X_susc", "double",
        std::vector<size_t>{static_cast<size_t>(N),
          static_cast<size_t>(K_susc)});
      X_susc_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, K_susc,
                        std::numeric_limits<double>::quiet_NaN());
      new (&X_susc)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_susc_data__.data(), N,
        K_susc);
      {
        std::vector<local_scalar_t__> X_susc_flat__;
        current_statement__ = 215;
        X_susc_flat__ = context__.vals_r("X_susc");
        current_statement__ = 215;
        pos__ = 1;
        current_statement__ = 215;
        for (int sym1__ = 1; sym1__ <= K_susc; ++sym1__) {
          current_statement__ = 215;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 215;
            stan::model::assign(X_susc, X_susc_flat__[(pos__ - 1)],
              "assigning variable X_susc", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 215;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 216;
      context__.validate_dims("data initialization", "K_inf", "int",
        std::vector<size_t>{});
      K_inf = std::numeric_limits<int>::min();
      current_statement__ = 216;
      K_inf = context__.vals_i("K_inf")[(1 - 1)];
      current_statement__ = 216;
      stan::math::check_greater_or_equal(function__, "K_inf", K_inf, 0);
      current_statement__ = 217;
      stan::math::validate_non_negative_index("X_inf", "N", N);
      current_statement__ = 218;
      stan::math::validate_non_negative_index("X_inf", "K_inf", K_inf);
      current_statement__ = 219;
      context__.validate_dims("data initialization", "X_inf", "double",
        std::vector<size_t>{static_cast<size_t>(N),
          static_cast<size_t>(K_inf)});
      X_inf_data__ = Eigen::Matrix<double,-1,-1>::Constant(N, K_inf,
                       std::numeric_limits<double>::quiet_NaN());
      new (&X_inf)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_inf_data__.data(), N,
        K_inf);
      {
        std::vector<local_scalar_t__> X_inf_flat__;
        current_statement__ = 219;
        X_inf_flat__ = context__.vals_r("X_inf");
        current_statement__ = 219;
        pos__ = 1;
        current_statement__ = 219;
        for (int sym1__ = 1; sym1__ <= K_inf; ++sym1__) {
          current_statement__ = 219;
          for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
            current_statement__ = 219;
            stan::model::assign(X_inf, X_inf_flat__[(pos__ - 1)],
              "assigning variable X_inf", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 219;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 220;
      context__.validate_dims("data initialization", "prior_beta1_type",
        "int", std::vector<size_t>{});
      prior_beta1_type = std::numeric_limits<int>::min();
      current_statement__ = 220;
      prior_beta1_type = context__.vals_i("prior_beta1_type")[(1 - 1)];
      current_statement__ = 220;
      stan::math::check_greater_or_equal(function__, "prior_beta1_type",
        prior_beta1_type, 0);
      current_statement__ = 221;
      context__.validate_dims("data initialization", "prior_beta1_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_beta1_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_beta1_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_beta1_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_beta1_params_flat__;
        current_statement__ = 221;
        prior_beta1_params_flat__ = context__.vals_r("prior_beta1_params");
        current_statement__ = 221;
        pos__ = 1;
        current_statement__ = 221;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 221;
          stan::model::assign(prior_beta1_params,
            prior_beta1_params_flat__[(pos__ - 1)],
            "assigning variable prior_beta1_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 221;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 222;
      context__.validate_dims("data initialization", "prior_beta2_type",
        "int", std::vector<size_t>{});
      prior_beta2_type = std::numeric_limits<int>::min();
      current_statement__ = 222;
      prior_beta2_type = context__.vals_i("prior_beta2_type")[(1 - 1)];
      current_statement__ = 222;
      stan::math::check_greater_or_equal(function__, "prior_beta2_type",
        prior_beta2_type, 0);
      current_statement__ = 223;
      context__.validate_dims("data initialization", "prior_beta2_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_beta2_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_beta2_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_beta2_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_beta2_params_flat__;
        current_statement__ = 223;
        prior_beta2_params_flat__ = context__.vals_r("prior_beta2_params");
        current_statement__ = 223;
        pos__ = 1;
        current_statement__ = 223;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 223;
          stan::model::assign(prior_beta2_params,
            prior_beta2_params_flat__[(pos__ - 1)],
            "assigning variable prior_beta2_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 223;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 224;
      context__.validate_dims("data initialization", "prior_alpha_type",
        "int", std::vector<size_t>{});
      prior_alpha_type = std::numeric_limits<int>::min();
      current_statement__ = 224;
      prior_alpha_type = context__.vals_i("prior_alpha_type")[(1 - 1)];
      current_statement__ = 224;
      stan::math::check_greater_or_equal(function__, "prior_alpha_type",
        prior_alpha_type, 0);
      current_statement__ = 225;
      context__.validate_dims("data initialization", "prior_alpha_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_alpha_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_alpha_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_alpha_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_alpha_params_flat__;
        current_statement__ = 225;
        prior_alpha_params_flat__ = context__.vals_r("prior_alpha_params");
        current_statement__ = 225;
        pos__ = 1;
        current_statement__ = 225;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 225;
          stan::model::assign(prior_alpha_params,
            prior_alpha_params_flat__[(pos__ - 1)],
            "assigning variable prior_alpha_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 225;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 226;
      context__.validate_dims("data initialization", "prior_cov_type", "int",
        std::vector<size_t>{});
      prior_cov_type = std::numeric_limits<int>::min();
      current_statement__ = 226;
      prior_cov_type = context__.vals_i("prior_cov_type")[(1 - 1)];
      current_statement__ = 226;
      stan::math::check_greater_or_equal(function__, "prior_cov_type",
        prior_cov_type, 0);
      current_statement__ = 227;
      context__.validate_dims("data initialization", "prior_cov_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_cov_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                  std::numeric_limits<double>::quiet_NaN());
      new (&prior_cov_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_cov_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_cov_params_flat__;
        current_statement__ = 227;
        prior_cov_params_flat__ = context__.vals_r("prior_cov_params");
        current_statement__ = 227;
        pos__ = 1;
        current_statement__ = 227;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 227;
          stan::model::assign(prior_cov_params,
            prior_cov_params_flat__[(pos__ - 1)],
            "assigning variable prior_cov_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 227;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 228;
      context__.validate_dims("data initialization", "prior_shape_type",
        "int", std::vector<size_t>{});
      prior_shape_type = std::numeric_limits<int>::min();
      current_statement__ = 228;
      prior_shape_type = context__.vals_i("prior_shape_type")[(1 - 1)];
      current_statement__ = 228;
      stan::math::check_greater_or_equal(function__, "prior_shape_type",
        prior_shape_type, 0);
      current_statement__ = 229;
      context__.validate_dims("data initialization", "prior_shape_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_shape_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_shape_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_shape_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_shape_params_flat__;
        current_statement__ = 229;
        prior_shape_params_flat__ = context__.vals_r("prior_shape_params");
        current_statement__ = 229;
        pos__ = 1;
        current_statement__ = 229;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 229;
          stan::model::assign(prior_shape_params,
            prior_shape_params_flat__[(pos__ - 1)],
            "assigning variable prior_shape_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 229;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 230;
      context__.validate_dims("data initialization", "prior_rate_type",
        "int", std::vector<size_t>{});
      prior_rate_type = std::numeric_limits<int>::min();
      current_statement__ = 230;
      prior_rate_type = context__.vals_i("prior_rate_type")[(1 - 1)];
      current_statement__ = 230;
      stan::math::check_greater_or_equal(function__, "prior_rate_type",
        prior_rate_type, 0);
      current_statement__ = 231;
      context__.validate_dims("data initialization", "prior_rate_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_rate_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                   std::numeric_limits<double>::quiet_NaN());
      new (&prior_rate_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_rate_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_rate_params_flat__;
        current_statement__ = 231;
        prior_rate_params_flat__ = context__.vals_r("prior_rate_params");
        current_statement__ = 231;
        pos__ = 1;
        current_statement__ = 231;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 231;
          stan::model::assign(prior_rate_params,
            prior_rate_params_flat__[(pos__ - 1)],
            "assigning variable prior_rate_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 231;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 232;
      context__.validate_dims("data initialization", "prior_ct50_type",
        "int", std::vector<size_t>{});
      prior_ct50_type = std::numeric_limits<int>::min();
      current_statement__ = 232;
      prior_ct50_type = context__.vals_i("prior_ct50_type")[(1 - 1)];
      current_statement__ = 232;
      stan::math::check_greater_or_equal(function__, "prior_ct50_type",
        prior_ct50_type, 0);
      current_statement__ = 233;
      context__.validate_dims("data initialization", "prior_ct50_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_ct50_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                   std::numeric_limits<double>::quiet_NaN());
      new (&prior_ct50_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_ct50_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_ct50_params_flat__;
        current_statement__ = 233;
        prior_ct50_params_flat__ = context__.vals_r("prior_ct50_params");
        current_statement__ = 233;
        pos__ = 1;
        current_statement__ = 233;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 233;
          stan::model::assign(prior_ct50_params,
            prior_ct50_params_flat__[(pos__ - 1)],
            "assigning variable prior_ct50_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 233;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 234;
      context__.validate_dims("data initialization", "prior_slope_type",
        "int", std::vector<size_t>{});
      prior_slope_type = std::numeric_limits<int>::min();
      current_statement__ = 234;
      prior_slope_type = context__.vals_i("prior_slope_type")[(1 - 1)];
      current_statement__ = 234;
      stan::math::check_greater_or_equal(function__, "prior_slope_type",
        prior_slope_type, 0);
      current_statement__ = 235;
      context__.validate_dims("data initialization", "prior_slope_params",
        "double", std::vector<size_t>{static_cast<size_t>(2)});
      prior_slope_params_data__ = Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_slope_params)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_slope_params_data__.data(),
        2);
      {
        std::vector<local_scalar_t__> prior_slope_params_flat__;
        current_statement__ = 235;
        prior_slope_params_flat__ = context__.vals_r("prior_slope_params");
        current_statement__ = 235;
        pos__ = 1;
        current_statement__ = 235;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 235;
          stan::model::assign(prior_slope_params,
            prior_slope_params_flat__[(pos__ - 1)],
            "assigning variable prior_slope_params",
            stan::model::index_uni(sym1__));
          current_statement__ = 235;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 236;
      stan::math::validate_non_negative_index("infection_day", "N", N);
      current_statement__ = 237;
      infection_day = std::vector<int>(N, std::numeric_limits<int>::min());
      current_statement__ = 246;
      for (int n = 1; n <= N; ++n) {
        current_statement__ = 238;
        stan::model::assign(infection_day, 0,
          "assigning variable infection_day", stan::model::index_uni(n));
        current_statement__ = 244;
        for (int t =
               stan::model::rvalue(start_risk, "start_risk",
                 stan::model::index_uni(n)); t <= T; ++t) {
          current_statement__ = 242;
          if (stan::math::logical_eq(
                stan::model::rvalue(I, "I", stan::model::index_uni(n),
                  stan::model::index_uni(t)), 1)) {
            current_statement__ = 239;
            stan::model::assign(infection_day, t,
              "assigning variable infection_day", stan::model::index_uni(n));
            break;
          }
        }
      }
      current_statement__ = 247;
      log_phi_by_role_raw_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 247;
      log_phi_by_role_raw_1dim__ = (R - 1);
      current_statement__ = 247;
      stan::math::validate_non_negative_index("log_phi_by_role_raw", "R - 1",
        log_phi_by_role_raw_1dim__);
      current_statement__ = 248;
      log_kappa_by_role_raw_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 248;
      log_kappa_by_role_raw_1dim__ = (R - 1);
      current_statement__ = 248;
      stan::math::validate_non_negative_index("log_kappa_by_role_raw",
        "R - 1", log_kappa_by_role_raw_1dim__);
      current_statement__ = 249;
      stan::math::validate_non_negative_index("beta_susc", "K_susc", K_susc);
      current_statement__ = 250;
      stan::math::validate_non_negative_index("beta_inf", "K_inf", K_inf);
      current_statement__ = 251;
      stan::math::validate_non_negative_index("phi_by_role", "R", R);
      current_statement__ = 252;
      stan::math::validate_non_negative_index("kappa_by_role", "R", R);
      current_statement__ = 253;
      stan::math::validate_non_negative_index("g_curve_est", "T", T);
      current_statement__ = 254;
      stan::math::validate_non_negative_index("V_term_calc", "N", N);
      current_statement__ = 255;
      stan::math::validate_non_negative_index("V_term_calc", "T", T);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = log_phi_by_role_raw_1dim__ +
      log_kappa_by_role_raw_1dim__ + 1 + 1 + 1 + 1 + 1 + 1 + 1 + K_susc +
      K_inf;
  }
  inline std::string model_name() const final {
    return "model_household_transmission";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_household_transmission_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<local_scalar_t__,-1,1> log_phi_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_phi_by_role_raw_1dim__,
          DUMMY_VAR__);
      current_statement__ = 1;
      log_phi_by_role_raw = in__.template read<
                              Eigen::Matrix<local_scalar_t__,-1,1>>(log_phi_by_role_raw_1dim__);
      Eigen::Matrix<local_scalar_t__,-1,1> log_kappa_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_kappa_by_role_raw_1dim__,
          DUMMY_VAR__);
      current_statement__ = 2;
      log_kappa_by_role_raw = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,1>>(log_kappa_by_role_raw_1dim__);
      local_scalar_t__ log_beta1 = DUMMY_VAR__;
      current_statement__ = 3;
      log_beta1 = in__.template read<local_scalar_t__>();
      local_scalar_t__ log_beta2 = DUMMY_VAR__;
      current_statement__ = 4;
      log_beta2 = in__.template read<local_scalar_t__>();
      local_scalar_t__ log_alpha_comm = DUMMY_VAR__;
      current_statement__ = 5;
      log_alpha_comm = in__.template read<local_scalar_t__>();
      local_scalar_t__ gen_shape = DUMMY_VAR__;
      current_statement__ = 6;
      gen_shape = in__.template read_constrain_lub<local_scalar_t__,
                    jacobian__>(1.0, 20.0, lp__);
      local_scalar_t__ gen_rate = DUMMY_VAR__;
      current_statement__ = 7;
      gen_rate = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0.1, 5.0, lp__);
      local_scalar_t__ Ct50 = DUMMY_VAR__;
      current_statement__ = 8;
      Ct50 = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      local_scalar_t__ slope_ct = DUMMY_VAR__;
      current_statement__ = 9;
      slope_ct = in__.template read_constrain_lb<local_scalar_t__,
                   jacobian__>(0, lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_susc =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_susc, DUMMY_VAR__);
      current_statement__ = 10;
      beta_susc = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,1>>(K_susc);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_inf =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_inf, DUMMY_VAR__);
      current_statement__ = 11;
      beta_inf = in__.template read<
                   Eigen::Matrix<local_scalar_t__,-1,1>>(K_inf);
      Eigen::Matrix<local_scalar_t__,-1,1> phi_by_role =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(R, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> kappa_by_role =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(R, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,1> g_curve_est =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(T, DUMMY_VAR__);
      local_scalar_t__ alpha_comm = DUMMY_VAR__;
      current_statement__ = 15;
      alpha_comm = stan::math::exp(log_alpha_comm);
      local_scalar_t__ beta1 = DUMMY_VAR__;
      current_statement__ = 16;
      beta1 = stan::math::exp(log_beta1);
      local_scalar_t__ beta2 = DUMMY_VAR__;
      current_statement__ = 17;
      beta2 = stan::math::exp(log_beta2);
      current_statement__ = 19;
      stan::model::assign(phi_by_role, reference_phi,
        "assigning variable phi_by_role", stan::model::index_uni(1));
      current_statement__ = 22;
      for (int r = 2; r <= R; ++r) {
        current_statement__ = 20;
        stan::model::assign(phi_by_role, (reference_phi *
          stan::math::exp(
            stan::model::rvalue(log_phi_by_role_raw, "log_phi_by_role_raw",
              stan::model::index_uni((r - 1))))),
          "assigning variable phi_by_role", stan::model::index_uni(r));
      }
      current_statement__ = 23;
      stan::model::assign(kappa_by_role, reference_kappa,
        "assigning variable kappa_by_role", stan::model::index_uni(1));
      current_statement__ = 26;
      for (int r = 2; r <= R; ++r) {
        current_statement__ = 24;
        stan::model::assign(kappa_by_role, (reference_kappa *
          stan::math::exp(
            stan::model::rvalue(log_kappa_by_role_raw,
              "log_kappa_by_role_raw", stan::model::index_uni((r - 1))))),
          "assigning variable kappa_by_role", stan::model::index_uni(r));
      }
      {
        current_statement__ = 27;
        stan::math::validate_non_negative_index("raw_curve", "T", T);
        Eigen::Matrix<local_scalar_t__,-1,1> raw_curve =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(T, DUMMY_VAR__);
        current_statement__ = 31;
        for (int d = 1; d <= T; ++d) {
          current_statement__ = 29;
          stan::model::assign(raw_curve,
            stan::math::exp(
              stan::math::gamma_lpdf<false>(d, gen_shape, gen_rate)),
            "assigning variable raw_curve", stan::model::index_uni(d));
        }
        current_statement__ = 32;
        stan::model::assign(g_curve_est,
          stan::math::divide(raw_curve, stan::math::max(raw_curve)),
          "assigning variable g_curve_est");
      }
      Eigen::Matrix<local_scalar_t__,-1,-1> V_term_calc =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(N, T, DUMMY_VAR__);
      current_statement__ = 18;
      stan::model::assign(V_term_calc, stan::math::rep_matrix(0.0, N, T),
        "assigning variable V_term_calc");
      current_statement__ = 47;
      if (stan::math::logical_eq(use_vl_data, 1)) {
        current_statement__ = 45;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 43;
          for (int t = 1; t <= T; ++t) {
            current_statement__ = 41;
            if (stan::math::logical_eq(
                  stan::model::rvalue(Y, "Y", stan::model::index_uni(n),
                    stan::model::index_uni(t)), 1)) {
              local_scalar_t__ val = DUMMY_VAR__;
              current_statement__ = 34;
              val = stan::model::rvalue(V, "V", stan::model::index_uni(n),
                      stan::model::index_uni(t));
              current_statement__ = 39;
              if (stan::math::logical_eq(vl_type, 1)) {
                current_statement__ = 37;
                stan::model::assign(V_term_calc,
                  stan::math::pow((stan::math::fmax(0.0, val) / Ct50),
                    slope_ct), "assigning variable V_term_calc",
                  stan::model::index_uni(n), stan::model::index_uni(t));
              } else {
                current_statement__ = 35;
                stan::model::assign(V_term_calc,
                  stan::math::inv_logit(((Ct50 - val) / slope_ct)),
                  "assigning variable V_term_calc",
                  stan::model::index_uni(n), stan::model::index_uni(t));
              }
            }
          }
        }
      }
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "phi_by_role",
        phi_by_role, 0);
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "kappa_by_role",
        kappa_by_role, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "alpha_comm",
        alpha_comm, 0);
      {
        current_statement__ = 48;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(log_phi_by_role_raw,
                         0, 1));
        current_statement__ = 49;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(
                         log_kappa_by_role_raw, 0, 1));
        current_statement__ = 55;
        if (stan::math::logical_eq(prior_beta1_type, 1)) {
          current_statement__ = 53;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(log_beta1,
                           stan::model::rvalue(prior_beta1_params,
                             "prior_beta1_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_beta1_params,
                             "prior_beta1_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 52;
          if (stan::math::logical_eq(prior_beta1_type, 2)) {
            current_statement__ = 50;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(log_beta1,
                             stan::model::rvalue(prior_beta1_params,
                               "prior_beta1_params",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(prior_beta1_params,
                               "prior_beta1_params",
                               stan::model::index_uni(2))));
          }
        }
        current_statement__ = 61;
        if (stan::math::logical_eq(prior_beta2_type, 1)) {
          current_statement__ = 59;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(log_beta2,
                           stan::model::rvalue(prior_beta2_params,
                             "prior_beta2_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_beta2_params,
                             "prior_beta2_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 58;
          if (stan::math::logical_eq(prior_beta2_type, 2)) {
            current_statement__ = 56;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(log_beta2,
                             stan::model::rvalue(prior_beta2_params,
                               "prior_beta2_params",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(prior_beta2_params,
                               "prior_beta2_params",
                               stan::model::index_uni(2))));
          }
        }
        current_statement__ = 67;
        if (stan::math::logical_eq(prior_alpha_type, 1)) {
          current_statement__ = 65;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(log_alpha_comm,
                           stan::model::rvalue(prior_alpha_params,
                             "prior_alpha_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_alpha_params,
                             "prior_alpha_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 64;
          if (stan::math::logical_eq(prior_alpha_type, 2)) {
            current_statement__ = 62;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(log_alpha_comm,
                             stan::model::rvalue(prior_alpha_params,
                               "prior_alpha_params",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(prior_alpha_params,
                               "prior_alpha_params",
                               stan::model::index_uni(2))));
          }
        }
        current_statement__ = 75;
        if (stan::math::logical_gt(K_susc, 0)) {
          current_statement__ = 73;
          if (stan::math::logical_eq(prior_cov_type, 1)) {
            current_statement__ = 71;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(beta_susc,
                             stan::model::rvalue(prior_cov_params,
                               "prior_cov_params", stan::model::index_uni(1)),
                             stan::model::rvalue(prior_cov_params,
                               "prior_cov_params", stan::model::index_uni(2))));
          } else {
            current_statement__ = 70;
            if (stan::math::logical_eq(prior_cov_type, 2)) {
              current_statement__ = 68;
              lp_accum__.add(stan::math::uniform_lpdf<propto__>(beta_susc,
                               stan::model::rvalue(prior_cov_params,
                                 "prior_cov_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_cov_params,
                                 "prior_cov_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 83;
        if (stan::math::logical_gt(K_inf, 0)) {
          current_statement__ = 81;
          if (stan::math::logical_eq(prior_cov_type, 1)) {
            current_statement__ = 79;
            lp_accum__.add(stan::math::normal_lpdf<propto__>(beta_inf,
                             stan::model::rvalue(prior_cov_params,
                               "prior_cov_params", stan::model::index_uni(1)),
                             stan::model::rvalue(prior_cov_params,
                               "prior_cov_params", stan::model::index_uni(2))));
          } else {
            current_statement__ = 78;
            if (stan::math::logical_eq(prior_cov_type, 2)) {
              current_statement__ = 76;
              lp_accum__.add(stan::math::uniform_lpdf<propto__>(beta_inf,
                               stan::model::rvalue(prior_cov_params,
                                 "prior_cov_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_cov_params,
                                 "prior_cov_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 92;
        if (stan::math::logical_eq(prior_shape_type, 1)) {
          current_statement__ = 90;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(gen_shape,
                           stan::model::rvalue(prior_shape_params,
                             "prior_shape_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_shape_params,
                             "prior_shape_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 89;
          if (stan::math::logical_eq(prior_shape_type, 2)) {
            current_statement__ = 87;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(gen_shape,
                             stan::model::rvalue(prior_shape_params,
                               "prior_shape_params",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(prior_shape_params,
                               "prior_shape_params",
                               stan::model::index_uni(2))));
          } else {
            current_statement__ = 86;
            if (stan::math::logical_eq(prior_shape_type, 3)) {
              current_statement__ = 84;
              lp_accum__.add(stan::math::lognormal_lpdf<propto__>(gen_shape,
                               stan::model::rvalue(prior_shape_params,
                                 "prior_shape_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_shape_params,
                                 "prior_shape_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 101;
        if (stan::math::logical_eq(prior_rate_type, 1)) {
          current_statement__ = 99;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(gen_rate,
                           stan::model::rvalue(prior_rate_params,
                             "prior_rate_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_rate_params,
                             "prior_rate_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 98;
          if (stan::math::logical_eq(prior_rate_type, 2)) {
            current_statement__ = 96;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(gen_rate,
                             stan::model::rvalue(prior_rate_params,
                               "prior_rate_params", stan::model::index_uni(1)),
                             stan::model::rvalue(prior_rate_params,
                               "prior_rate_params", stan::model::index_uni(2))));
          } else {
            current_statement__ = 95;
            if (stan::math::logical_eq(prior_rate_type, 3)) {
              current_statement__ = 93;
              lp_accum__.add(stan::math::lognormal_lpdf<propto__>(gen_rate,
                               stan::model::rvalue(prior_rate_params,
                                 "prior_rate_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_rate_params,
                                 "prior_rate_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 110;
        if (stan::math::logical_eq(prior_ct50_type, 1)) {
          current_statement__ = 108;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(Ct50,
                           stan::model::rvalue(prior_ct50_params,
                             "prior_ct50_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_ct50_params,
                             "prior_ct50_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 107;
          if (stan::math::logical_eq(prior_ct50_type, 2)) {
            current_statement__ = 105;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(Ct50,
                             stan::model::rvalue(prior_ct50_params,
                               "prior_ct50_params", stan::model::index_uni(1)),
                             stan::model::rvalue(prior_ct50_params,
                               "prior_ct50_params", stan::model::index_uni(2))));
          } else {
            current_statement__ = 104;
            if (stan::math::logical_eq(prior_ct50_type, 3)) {
              current_statement__ = 102;
              lp_accum__.add(stan::math::lognormal_lpdf<propto__>(Ct50,
                               stan::model::rvalue(prior_ct50_params,
                                 "prior_ct50_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_ct50_params,
                                 "prior_ct50_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 119;
        if (stan::math::logical_eq(prior_slope_type, 1)) {
          current_statement__ = 117;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(slope_ct,
                           stan::model::rvalue(prior_slope_params,
                             "prior_slope_params", stan::model::index_uni(1)),
                           stan::model::rvalue(prior_slope_params,
                             "prior_slope_params", stan::model::index_uni(2))));
        } else {
          current_statement__ = 116;
          if (stan::math::logical_eq(prior_slope_type, 2)) {
            current_statement__ = 114;
            lp_accum__.add(stan::math::uniform_lpdf<propto__>(slope_ct,
                             stan::model::rvalue(prior_slope_params,
                               "prior_slope_params",
                               stan::model::index_uni(1)),
                             stan::model::rvalue(prior_slope_params,
                               "prior_slope_params",
                               stan::model::index_uni(2))));
          } else {
            current_statement__ = 113;
            if (stan::math::logical_eq(prior_slope_type, 3)) {
              current_statement__ = 111;
              lp_accum__.add(stan::math::lognormal_lpdf<propto__>(slope_ct,
                               stan::model::rvalue(prior_slope_params,
                                 "prior_slope_params",
                                 stan::model::index_uni(1)),
                               stan::model::rvalue(prior_slope_params,
                                 "prior_slope_params",
                                 stan::model::index_uni(2))));
            }
          }
        }
        current_statement__ = 175;
        for (int n = 1; n <= N; ++n) {
          int t_stop = std::numeric_limits<int>::min();
          current_statement__ = 120;
          t_stop = (stan::math::logical_eq(
                      stan::model::rvalue(infection_day, "infection_day",
                        stan::model::index_uni(n)), 0) ? T : stan::model::rvalue(
                                                               infection_day,
                                                               "infection_day",
                                                               stan::model::index_uni(
                                                                 n)));
          local_scalar_t__ log_susc_mod = DUMMY_VAR__;
          current_statement__ = 121;
          log_susc_mod = 0.0;
          current_statement__ = 124;
          if (stan::math::logical_gt(K_susc, 0)) {
            current_statement__ = 122;
            log_susc_mod = stan::math::dot_product(
                             stan::model::rvalue(X_susc, "X_susc",
                               stan::model::index_uni(n)), beta_susc);
          }
          local_scalar_t__ phi_eff = DUMMY_VAR__;
          current_statement__ = 125;
          phi_eff = (stan::model::rvalue(phi_by_role, "phi_by_role",
                       stan::model::index_uni(
                         stan::model::rvalue(role_id, "role_id",
                           stan::model::index_uni(n))))
            * stan::math::exp(log_susc_mod));
          current_statement__ = 173;
          for (int t =
                 stan::model::rvalue(start_risk, "start_risk",
                   stan::model::index_uni(n)); t <= t_stop; ++t) {
            local_scalar_t__ lambda = DUMMY_VAR__;
            current_statement__ = 126;
            lambda = 0.0;
            current_statement__ = 127;
            lambda = (lambda + ((phi_eff * alpha_comm) *
              stan::model::rvalue(seasonal_forcing_mat,
                "seasonal_forcing_mat", stan::model::index_uni(t),
                stan::model::index_uni(
                  stan::model::rvalue(role_id, "role_id",
                    stan::model::index_uni(n))))));
            int h = std::numeric_limits<int>::min();
            current_statement__ = 128;
            h = stan::model::rvalue(hh_id, "hh_id", stan::model::index_uni(n));
            local_scalar_t__ scaling_h = DUMMY_VAR__;
            current_statement__ = 129;
            scaling_h = stan::math::pow((1.0 /
                          stan::math::max(
                            stan::model::rvalue(hh_size_people,
                              "hh_size_people", stan::model::index_uni(h)), 1)),
                          delta);
            current_statement__ = 168;
            for (int m_idx = 1; m_idx <= hh_max_size; ++m_idx) {
              int m = std::numeric_limits<int>::min();
              current_statement__ = 130;
              m = stan::model::rvalue(hh_members, "hh_members",
                    stan::model::index_uni(h), stan::model::index_uni(m_idx));
              current_statement__ = 132;
              if (stan::math::logical_eq(m, 0)) {
                break;
              }
              current_statement__ = 134;
              if (stan::math::logical_eq(
                    stan::model::rvalue(p_id, "p_id",
                      stan::model::index_uni(m)),
                    stan::model::rvalue(p_id, "p_id",
                      stan::model::index_uni(n)))) {
                continue;
              }
              current_statement__ = 136;
              if (stan::math::logical_eq(m, n)) {
                continue;
              }
              current_statement__ = 138;
              if (stan::math::logical_eq(
                    stan::model::rvalue(Y, "Y", stan::model::index_uni(m),
                      stan::model::index_uni(t)), 0)) {
                continue;
              }
              local_scalar_t__ log_inf_mod = DUMMY_VAR__;
              current_statement__ = 139;
              log_inf_mod = 0.0;
              current_statement__ = 142;
              if (stan::math::logical_gt(K_inf, 0)) {
                current_statement__ = 140;
                log_inf_mod = stan::math::dot_product(
                                stan::model::rvalue(X_inf, "X_inf",
                                  stan::model::index_uni(m)), beta_inf);
              }
              local_scalar_t__ kappa_eff = DUMMY_VAR__;
              current_statement__ = 143;
              kappa_eff = (stan::model::rvalue(kappa_by_role,
                             "kappa_by_role",
                             stan::model::index_uni(
                               stan::model::rvalue(role_id, "role_id",
                                 stan::model::index_uni(m))))
                * stan::math::exp(log_inf_mod));
              local_scalar_t__ g_t = DUMMY_VAR__;
              current_statement__ = 144;
              g_t = 0.0;
              int m_infection_day = std::numeric_limits<int>::min();
              current_statement__ = 145;
              m_infection_day = stan::model::rvalue(infection_day,
                                  "infection_day", stan::model::index_uni(m));
              current_statement__ = 154;
              if ((stan::math::primitive_value(
                     stan::math::logical_neq(m_infection_day, 0))
                  &&
                  stan::math::primitive_value(
                    stan::math::logical_gte(t, m_infection_day)))) {
                int dt = std::numeric_limits<int>::min();
                current_statement__ = 146;
                dt = ((t - m_infection_day) + 1);
                current_statement__ = 152;
                if (stan::math::logical_eq(use_curve_logic, 1)) {
                  current_statement__ = 150;
                  if (stan::math::logical_lte(dt, T)) {
                    current_statement__ = 149;
                    g_t = stan::model::rvalue(g_curve_est, "g_curve_est",
                            stan::model::index_uni(dt));
                  }
                } else {
                  current_statement__ = 147;
                  g_t = 1.0;
                }
              }
              local_scalar_t__ v_comp = DUMMY_VAR__;
              current_statement__ = 155;
              v_comp = 0.0;
              current_statement__ = 158;
              if (stan::math::logical_eq(use_vl_data, 1)) {
                current_statement__ = 156;
                v_comp = stan::model::rvalue(V_term_calc, "V_term_calc",
                           stan::model::index_uni(m),
                           stan::model::index_uni(t));
              }
              local_scalar_t__ term_combined = DUMMY_VAR__;
              current_statement__ = 164;
              if (stan::math::logical_eq(use_vl_data, 0)) {
                current_statement__ = 162;
                term_combined = (beta1 + (beta2 * g_t));
              } else {
                current_statement__ = 160;
                term_combined = (beta1 + (beta2 * v_comp));
              }
              local_scalar_t__ h_mt = DUMMY_VAR__;
              current_statement__ = 165;
              h_mt = ((scaling_h * kappa_eff) * term_combined);
              current_statement__ = 166;
              lambda = (lambda + (phi_eff * h_mt));
            }
            current_statement__ = 169;
            lambda = stan::math::fmin(stan::math::fmax(lambda, 1e-12), 1e6);
            int outcome = std::numeric_limits<int>::min();
            current_statement__ = 170;
            outcome = (stan::math::logical_eq(t,
                         stan::model::rvalue(infection_day, "infection_day",
                           stan::model::index_uni(n))) ? 1 : 0);
            current_statement__ = 171;
            lp_accum__.add(stan::math::bernoulli_lpmf<false>(outcome, (1 -
                             stan::math::exp(-lambda))));
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_household_transmission_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      Eigen::Matrix<double,-1,1> log_phi_by_role_raw =
        Eigen::Matrix<double,-1,1>::Constant(log_phi_by_role_raw_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 1;
      log_phi_by_role_raw = in__.template read<
                              Eigen::Matrix<local_scalar_t__,-1,1>>(log_phi_by_role_raw_1dim__);
      Eigen::Matrix<double,-1,1> log_kappa_by_role_raw =
        Eigen::Matrix<double,-1,1>::Constant(log_kappa_by_role_raw_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      log_kappa_by_role_raw = in__.template read<
                                Eigen::Matrix<local_scalar_t__,-1,1>>(log_kappa_by_role_raw_1dim__);
      double log_beta1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      log_beta1 = in__.template read<local_scalar_t__>();
      double log_beta2 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      log_beta2 = in__.template read<local_scalar_t__>();
      double log_alpha_comm = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      log_alpha_comm = in__.template read<local_scalar_t__>();
      double gen_shape = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      gen_shape = in__.template read_constrain_lub<local_scalar_t__,
                    jacobian__>(1.0, 20.0, lp__);
      double gen_rate = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      gen_rate = in__.template read_constrain_lub<local_scalar_t__,
                   jacobian__>(0.1, 5.0, lp__);
      double Ct50 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 8;
      Ct50 = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      double slope_ct = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 9;
      slope_ct = in__.template read_constrain_lb<local_scalar_t__,
                   jacobian__>(0, lp__);
      Eigen::Matrix<double,-1,1> beta_susc =
        Eigen::Matrix<double,-1,1>::Constant(K_susc,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      beta_susc = in__.template read<
                    Eigen::Matrix<local_scalar_t__,-1,1>>(K_susc);
      Eigen::Matrix<double,-1,1> beta_inf =
        Eigen::Matrix<double,-1,1>::Constant(K_inf,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      beta_inf = in__.template read<
                   Eigen::Matrix<local_scalar_t__,-1,1>>(K_inf);
      Eigen::Matrix<double,-1,1> phi_by_role =
        Eigen::Matrix<double,-1,1>::Constant(R,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> kappa_by_role =
        Eigen::Matrix<double,-1,1>::Constant(R,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> g_curve_est =
        Eigen::Matrix<double,-1,1>::Constant(T,
          std::numeric_limits<double>::quiet_NaN());
      double alpha_comm = std::numeric_limits<double>::quiet_NaN();
      double beta1 = std::numeric_limits<double>::quiet_NaN();
      double beta2 = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,-1> V_term_calc =
        Eigen::Matrix<double,-1,-1>::Constant(N, T,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(log_phi_by_role_raw);
      out__.write(log_kappa_by_role_raw);
      out__.write(log_beta1);
      out__.write(log_beta2);
      out__.write(log_alpha_comm);
      out__.write(gen_shape);
      out__.write(gen_rate);
      out__.write(Ct50);
      out__.write(slope_ct);
      out__.write(beta_susc);
      out__.write(beta_inf);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 15;
      alpha_comm = stan::math::exp(log_alpha_comm);
      current_statement__ = 16;
      beta1 = stan::math::exp(log_beta1);
      current_statement__ = 17;
      beta2 = stan::math::exp(log_beta2);
      current_statement__ = 19;
      stan::model::assign(phi_by_role, reference_phi,
        "assigning variable phi_by_role", stan::model::index_uni(1));
      current_statement__ = 22;
      for (int r = 2; r <= R; ++r) {
        current_statement__ = 20;
        stan::model::assign(phi_by_role, (reference_phi *
          stan::math::exp(
            stan::model::rvalue(log_phi_by_role_raw, "log_phi_by_role_raw",
              stan::model::index_uni((r - 1))))),
          "assigning variable phi_by_role", stan::model::index_uni(r));
      }
      current_statement__ = 23;
      stan::model::assign(kappa_by_role, reference_kappa,
        "assigning variable kappa_by_role", stan::model::index_uni(1));
      current_statement__ = 26;
      for (int r = 2; r <= R; ++r) {
        current_statement__ = 24;
        stan::model::assign(kappa_by_role, (reference_kappa *
          stan::math::exp(
            stan::model::rvalue(log_kappa_by_role_raw,
              "log_kappa_by_role_raw", stan::model::index_uni((r - 1))))),
          "assigning variable kappa_by_role", stan::model::index_uni(r));
      }
      {
        current_statement__ = 27;
        stan::math::validate_non_negative_index("raw_curve", "T", T);
        Eigen::Matrix<double,-1,1> raw_curve =
          Eigen::Matrix<double,-1,1>::Constant(T,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 31;
        for (int d = 1; d <= T; ++d) {
          current_statement__ = 29;
          stan::model::assign(raw_curve,
            stan::math::exp(
              stan::math::gamma_lpdf<false>(d, gen_shape, gen_rate)),
            "assigning variable raw_curve", stan::model::index_uni(d));
        }
        current_statement__ = 32;
        stan::model::assign(g_curve_est,
          stan::math::divide(raw_curve, stan::math::max(raw_curve)),
          "assigning variable g_curve_est");
      }
      current_statement__ = 18;
      stan::model::assign(V_term_calc, stan::math::rep_matrix(0.0, N, T),
        "assigning variable V_term_calc");
      current_statement__ = 47;
      if (stan::math::logical_eq(use_vl_data, 1)) {
        current_statement__ = 45;
        for (int n = 1; n <= N; ++n) {
          current_statement__ = 43;
          for (int t = 1; t <= T; ++t) {
            current_statement__ = 41;
            if (stan::math::logical_eq(
                  stan::model::rvalue(Y, "Y", stan::model::index_uni(n),
                    stan::model::index_uni(t)), 1)) {
              double val = std::numeric_limits<double>::quiet_NaN();
              current_statement__ = 34;
              val = stan::model::rvalue(V, "V", stan::model::index_uni(n),
                      stan::model::index_uni(t));
              current_statement__ = 39;
              if (stan::math::logical_eq(vl_type, 1)) {
                current_statement__ = 37;
                stan::model::assign(V_term_calc,
                  stan::math::pow((stan::math::fmax(0.0, val) / Ct50),
                    slope_ct), "assigning variable V_term_calc",
                  stan::model::index_uni(n), stan::model::index_uni(t));
              } else {
                current_statement__ = 35;
                stan::model::assign(V_term_calc,
                  stan::math::inv_logit(((Ct50 - val) / slope_ct)),
                  "assigning variable V_term_calc",
                  stan::model::index_uni(n), stan::model::index_uni(t));
              }
            }
          }
        }
      }
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "phi_by_role",
        phi_by_role, 0);
      current_statement__ = 13;
      stan::math::check_greater_or_equal(function__, "kappa_by_role",
        kappa_by_role, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "alpha_comm",
        alpha_comm, 0);
      if (emit_transformed_parameters__) {
        out__.write(phi_by_role);
        out__.write(kappa_by_role);
        out__.write(g_curve_est);
        out__.write(alpha_comm);
        out__.write(beta1);
        out__.write(beta2);
        out__.write(V_term_calc);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> log_phi_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_phi_by_role_raw_1dim__,
          DUMMY_VAR__);
      current_statement__ = 1;
      stan::model::assign(log_phi_by_role_raw,
        in__.read<
          Eigen::Matrix<local_scalar_t__,-1,1>>(log_phi_by_role_raw_1dim__),
        "assigning variable log_phi_by_role_raw");
      out__.write(log_phi_by_role_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> log_kappa_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_kappa_by_role_raw_1dim__,
          DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(log_kappa_by_role_raw,
        in__.read<
          Eigen::Matrix<local_scalar_t__,-1,1>>(log_kappa_by_role_raw_1dim__),
        "assigning variable log_kappa_by_role_raw");
      out__.write(log_kappa_by_role_raw);
      local_scalar_t__ log_beta1 = DUMMY_VAR__;
      current_statement__ = 3;
      log_beta1 = in__.read<local_scalar_t__>();
      out__.write(log_beta1);
      local_scalar_t__ log_beta2 = DUMMY_VAR__;
      current_statement__ = 4;
      log_beta2 = in__.read<local_scalar_t__>();
      out__.write(log_beta2);
      local_scalar_t__ log_alpha_comm = DUMMY_VAR__;
      current_statement__ = 5;
      log_alpha_comm = in__.read<local_scalar_t__>();
      out__.write(log_alpha_comm);
      local_scalar_t__ gen_shape = DUMMY_VAR__;
      current_statement__ = 6;
      gen_shape = in__.read<local_scalar_t__>();
      out__.write_free_lub(1.0, 20.0, gen_shape);
      local_scalar_t__ gen_rate = DUMMY_VAR__;
      current_statement__ = 7;
      gen_rate = in__.read<local_scalar_t__>();
      out__.write_free_lub(0.1, 5.0, gen_rate);
      local_scalar_t__ Ct50 = DUMMY_VAR__;
      current_statement__ = 8;
      Ct50 = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, Ct50);
      local_scalar_t__ slope_ct = DUMMY_VAR__;
      current_statement__ = 9;
      slope_ct = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, slope_ct);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_susc =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_susc, DUMMY_VAR__);
      current_statement__ = 10;
      stan::model::assign(beta_susc,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K_susc),
        "assigning variable beta_susc");
      out__.write(beta_susc);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_inf =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_inf, DUMMY_VAR__);
      current_statement__ = 11;
      stan::model::assign(beta_inf,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K_inf),
        "assigning variable beta_inf");
      out__.write(beta_inf);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization",
        "log_phi_by_role_raw", "double",
        std::vector<size_t>{static_cast<size_t>(log_phi_by_role_raw_1dim__)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization",
        "log_kappa_by_role_raw", "double",
        std::vector<size_t>{static_cast<size_t>(log_kappa_by_role_raw_1dim__)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "log_beta1",
        "double", std::vector<size_t>{});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "log_beta2",
        "double", std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "log_alpha_comm",
        "double", std::vector<size_t>{});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "gen_shape",
        "double", std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "gen_rate",
        "double", std::vector<size_t>{});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "Ct50", "double",
        std::vector<size_t>{});
      current_statement__ = 9;
      context__.validate_dims("parameter initialization", "slope_ct",
        "double", std::vector<size_t>{});
      current_statement__ = 10;
      context__.validate_dims("parameter initialization", "beta_susc",
        "double", std::vector<size_t>{static_cast<size_t>(K_susc)});
      current_statement__ = 11;
      context__.validate_dims("parameter initialization", "beta_inf",
        "double", std::vector<size_t>{static_cast<size_t>(K_inf)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      Eigen::Matrix<local_scalar_t__,-1,1> log_phi_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_phi_by_role_raw_1dim__,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> log_phi_by_role_raw_flat__;
        current_statement__ = 1;
        log_phi_by_role_raw_flat__ = context__.vals_r("log_phi_by_role_raw");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= log_phi_by_role_raw_1dim__; ++sym1__) {
          current_statement__ = 1;
          stan::model::assign(log_phi_by_role_raw,
            log_phi_by_role_raw_flat__[(pos__ - 1)],
            "assigning variable log_phi_by_role_raw",
            stan::model::index_uni(sym1__));
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(log_phi_by_role_raw);
      Eigen::Matrix<local_scalar_t__,-1,1> log_kappa_by_role_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(log_kappa_by_role_raw_1dim__,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> log_kappa_by_role_raw_flat__;
        current_statement__ = 2;
        log_kappa_by_role_raw_flat__ = context__.vals_r("log_kappa_by_role_raw");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= log_kappa_by_role_raw_1dim__; ++sym1__) {
          current_statement__ = 2;
          stan::model::assign(log_kappa_by_role_raw,
            log_kappa_by_role_raw_flat__[(pos__ - 1)],
            "assigning variable log_kappa_by_role_raw",
            stan::model::index_uni(sym1__));
          current_statement__ = 2;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(log_kappa_by_role_raw);
      local_scalar_t__ log_beta1 = DUMMY_VAR__;
      current_statement__ = 3;
      log_beta1 = context__.vals_r("log_beta1")[(1 - 1)];
      out__.write(log_beta1);
      local_scalar_t__ log_beta2 = DUMMY_VAR__;
      current_statement__ = 4;
      log_beta2 = context__.vals_r("log_beta2")[(1 - 1)];
      out__.write(log_beta2);
      local_scalar_t__ log_alpha_comm = DUMMY_VAR__;
      current_statement__ = 5;
      log_alpha_comm = context__.vals_r("log_alpha_comm")[(1 - 1)];
      out__.write(log_alpha_comm);
      local_scalar_t__ gen_shape = DUMMY_VAR__;
      current_statement__ = 6;
      gen_shape = context__.vals_r("gen_shape")[(1 - 1)];
      out__.write_free_lub(1.0, 20.0, gen_shape);
      local_scalar_t__ gen_rate = DUMMY_VAR__;
      current_statement__ = 7;
      gen_rate = context__.vals_r("gen_rate")[(1 - 1)];
      out__.write_free_lub(0.1, 5.0, gen_rate);
      local_scalar_t__ Ct50 = DUMMY_VAR__;
      current_statement__ = 8;
      Ct50 = context__.vals_r("Ct50")[(1 - 1)];
      out__.write_free_lb(0, Ct50);
      local_scalar_t__ slope_ct = DUMMY_VAR__;
      current_statement__ = 9;
      slope_ct = context__.vals_r("slope_ct")[(1 - 1)];
      out__.write_free_lb(0, slope_ct);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_susc =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_susc, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_susc_flat__;
        current_statement__ = 10;
        beta_susc_flat__ = context__.vals_r("beta_susc");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= K_susc; ++sym1__) {
          current_statement__ = 10;
          stan::model::assign(beta_susc, beta_susc_flat__[(pos__ - 1)],
            "assigning variable beta_susc", stan::model::index_uni(sym1__));
          current_statement__ = 10;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(beta_susc);
      Eigen::Matrix<local_scalar_t__,-1,1> beta_inf =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K_inf, DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> beta_inf_flat__;
        current_statement__ = 11;
        beta_inf_flat__ = context__.vals_r("beta_inf");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= K_inf; ++sym1__) {
          current_statement__ = 11;
          stan::model::assign(beta_inf, beta_inf_flat__[(pos__ - 1)],
            "assigning variable beta_inf", stan::model::index_uni(sym1__));
          current_statement__ = 11;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(beta_inf);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"log_phi_by_role_raw",
                "log_kappa_by_role_raw", "log_beta1", "log_beta2",
                "log_alpha_comm", "gen_shape", "gen_rate", "Ct50",
                "slope_ct", "beta_susc", "beta_inf"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"phi_by_role", "kappa_by_role", "g_curve_est", "alpha_comm",
             "beta1", "beta2", "V_term_calc"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    log_phi_by_role_raw_1dim__)},
                std::vector<size_t>{static_cast<size_t>(
                                      log_kappa_by_role_raw_1dim__)},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(K_susc)},
                std::vector<size_t>{static_cast<size_t>(K_inf)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(R)},
             std::vector<size_t>{static_cast<size_t>(R)},
             std::vector<size_t>{static_cast<size_t>(T)},
             std::vector<size_t>{}, std::vector<size_t>{},
             std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(N),
               static_cast<size_t>(T)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= log_phi_by_role_raw_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "log_phi_by_role_raw" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= log_kappa_by_role_raw_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "log_kappa_by_role_raw" +
        '.' + std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "log_beta1");
    param_names__.emplace_back(std::string() + "log_beta2");
    param_names__.emplace_back(std::string() + "log_alpha_comm");
    param_names__.emplace_back(std::string() + "gen_shape");
    param_names__.emplace_back(std::string() + "gen_rate");
    param_names__.emplace_back(std::string() + "Ct50");
    param_names__.emplace_back(std::string() + "slope_ct");
    for (int sym1__ = 1; sym1__ <= K_susc; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_susc" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K_inf; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_inf" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        param_names__.emplace_back(std::string() + "phi_by_role" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        param_names__.emplace_back(std::string() + "kappa_by_role" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        param_names__.emplace_back(std::string() + "g_curve_est" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "alpha_comm");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "beta2");
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "V_term_calc" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= log_phi_by_role_raw_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "log_phi_by_role_raw" + '.'
        + std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= log_kappa_by_role_raw_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "log_kappa_by_role_raw" +
        '.' + std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "log_beta1");
    param_names__.emplace_back(std::string() + "log_beta2");
    param_names__.emplace_back(std::string() + "log_alpha_comm");
    param_names__.emplace_back(std::string() + "gen_shape");
    param_names__.emplace_back(std::string() + "gen_rate");
    param_names__.emplace_back(std::string() + "Ct50");
    param_names__.emplace_back(std::string() + "slope_ct");
    for (int sym1__ = 1; sym1__ <= K_susc; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_susc" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= K_inf; ++sym1__) {
      param_names__.emplace_back(std::string() + "beta_inf" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        param_names__.emplace_back(std::string() + "phi_by_role" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= R; ++sym1__) {
        param_names__.emplace_back(std::string() + "kappa_by_role" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        param_names__.emplace_back(std::string() + "g_curve_est" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "alpha_comm");
      param_names__.emplace_back(std::string() + "beta1");
      param_names__.emplace_back(std::string() + "beta2");
      for (int sym1__ = 1; sym1__ <= T; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= N; ++sym2__) {
          param_names__.emplace_back(std::string() + "V_term_calc" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"log_phi_by_role_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_phi_by_role_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"log_kappa_by_role_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_kappa_by_role_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"log_beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_beta2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_alpha_comm\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gen_shape\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gen_rate\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Ct50\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"slope_ct\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_susc\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K_susc) + "},\"block\":\"parameters\"},{\"name\":\"beta_inf\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K_inf) + "},\"block\":\"parameters\"},{\"name\":\"phi_by_role\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"kappa_by_role\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"g_curve_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_comm\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"V_term_calc\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"log_phi_by_role_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_phi_by_role_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"log_kappa_by_role_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(log_kappa_by_role_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"log_beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_beta2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"log_alpha_comm\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gen_shape\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gen_rate\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"Ct50\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"slope_ct\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_susc\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K_susc) + "},\"block\":\"parameters\"},{\"name\":\"beta_inf\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K_inf) + "},\"block\":\"parameters\"},{\"name\":\"phi_by_role\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"kappa_by_role\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(R) + "},\"block\":\"transformed_parameters\"},{\"name\":\"g_curve_est\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_comm\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta2\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"V_term_calc\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(N) + ",\"cols\":" + std::to_string(T) + "},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((log_phi_by_role_raw_1dim__ +
      log_kappa_by_role_raw_1dim__) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      K_susc) + K_inf);
    const size_t num_transformed = emit_transformed_parameters * (((((((R +
      R) + T) + 1) + 1) + 1) + (N * T)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((((((log_phi_by_role_raw_1dim__ +
      log_kappa_by_role_raw_1dim__) + 1) + 1) + 1) + 1) + 1) + 1) + 1) +
      K_susc) + K_inf);
    const size_t num_transformed = emit_transformed_parameters * (((((((R +
      R) + T) + 1) + 1) + 1) + (N * T)));
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_household_transmission_namespace::model_household_transmission;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_household_transmission_namespace::profiles__;
}
#endif
#endif
